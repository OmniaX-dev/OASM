Instructions
------------

com, flags, command, [param]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	command = PrintInt
		flg2 = int's byte to print
		param = int's addr
	command = PrintString
		flg1 = StringReadMode
		param = string's addr
	command = PrintNewLine
		flags = 0
		NO PARAM
	command = StringLength
		flg1 = StringReadMode
		param = string's addr
		R23 = String's length
	command = GetArgsData
		flags = 0
		NO PARAM
		R23 = arg count
		R22 = addr of first arg on heap (or 0 if no args)
	command = External
		flg1 = StringReadMode (for param)
		param = addr of String param (or 0 if no param)
		R22 = result of command (bool, either 0 or 1)
		Needs:
			R23 = External command code

inc/dec, flags, dest
~~~~~~~~~~~~~~~~~~~~
	flg2 = Dest Byte

add/sub/mul/div, flags, op1, op2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	flg1 = Assign Type
	flg2 = Dest Byte
	flg3 = Src Byte

flg, flags
~~~~~~~~~~
	fullFlg = Flags to assign to FL register
	FL = flags

cmp, flags, v1, v2
~~~~~~~~~~~~~~~~~~
	flg1 = Compare Type
	flg2 = v1 Byte
	flg3 = v2 Byte
	CF = Compare result

mov/mem, flags, dest, src
~~~~~~~
	flg1 = Assign Type
	flg2 = Dest Byte
	flg3 = Src Byte
	StringAssign syntax
	~~~~~~~~~~~~~~~~~~~
	mov/mem, flags, str_ptr, stringLen, str_cell_1, ... , str_cell_n, StringEnd (0)
		flg1 = NormalAssign
		flg2 = ALL
		flg3 = ALL
		flg4 = StringAssign
		str_ptr = pre-allocated heap pointer with enough space for string
		str_cell_ = String mem_cells in compact form
		StringEnd = 0

jmp, flags, code_addr
~~~~~~~~~~
	flg1 = Jump condition
	code_addr = Address of code where to jump to
	Needs:
		CF = Has to hold a compare state from a <cmp> Instruction

cat, flags, str_ptr, value
~~~~~~~~~~~~~~~~~~~~~~~~~~
	flg2 = Concat Type
	StringIntConcat
		flg1 = Assign Type
		flg3 = value's Byte
		value = int value/location
	StringCharConcat
		flg1 = Assign Type
		flg3 = value's Byte
		value = char value/location
	StringStringConcat
		value = valid string heap-pointer
	StringConstStrConcat
		value = constant string data
	str_ptr = valid string heap-pointer with enough space to store new string 

call, flags, nip, param_count, assign_type_1, param_1, ... , ... , assign_type_n, param_n
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	nip = new instruction to jump to
	param_count = number of params (0 to n)
	assign_type_* = Assign Type for every param
	param_* = param value/pointer

push, flags, op
~~~~~~~~~~~~~~~
	flg1 = Assign Type
	flg2 = op's Byte
	op = value/pointer to push

pop, flags, reg
~~~~~~~~~~~~~~~
	flg4 = if set to StackRead, then data won't be removed from Stack
	reg = Register address where to store the data

ret, flags, ret_val
~~~~~~~~~~~~~~~~~~~
	flg1 = Assign Type
	flg2 = ret_val's Byte
	ret_val = value/pointer to return
	RV = ret_val

end, flags
~~~~~~~~~~
	flg1 = Exit code
	ES = flg1
alloc_h, size_addr
~~~~~~~~~~~~~~~~~~
	size_addr = addr of mem_cell containing size for new heap block
	R23 = new heap-pointer
free_h, heap_ptr
~~~~~~~~~~~~~~~~
	heap_ptr = valid allocated heap_ptr
req_stack, size
~~~~~~~~~~~~~~~
	size = Stack size to request
req_heap, size
~~~~~~~~~~~~~~
	size = Heap size to request
req_local, size
~~~~~~~~~~~~~~~
	size = Static-memory size to request